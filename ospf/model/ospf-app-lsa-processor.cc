/* -*- Mode:C++; c-file-style:"gnu"; indent-tabs-mode:nil; -*- */

#include "ospf-app-lsa-processor.h"

#include "ospf-app-private.h"

namespace ns3 {

OspfLsaProcessor::OspfLsaProcessor (OspfApp &app)
  : m_app (app)
{
}

void
OspfLsaProcessor::HandleLsr (uint32_t ifIndex, Ipv4Header ipHeader, OspfHeader ospfHeader,
                             Ptr<LsRequest> lsr)
{
  auto interface = m_app.m_ospfInterfaces[ifIndex];
  Ptr<OspfNeighbor> neighbor =
      interface->GetNeighbor (Ipv4Address (ospfHeader.GetRouterId ()), ipHeader.GetSource ());

  if (neighbor == nullptr)
    {
      return;
    }
  if (neighbor->GetState () < OspfNeighbor::Loading)
    {
      NS_LOG_WARN ("Received LSR when the state is not at least Loading");
    }
  // Construct LS Update as implicit ACK based on received lsr
  std::vector<Ptr<LsUpdate>> lsUpdates;
  Ptr<LsUpdate> lsUpdate = Create<LsUpdate> ();
  // TODO: Clean up
  for (auto &[remoteRouterId, lsa] : m_app.m_routerLsdb)
    {
      if (lsr->HasLsaKey (lsa.first.GetKey ()))
        {
          if (lsUpdate->GetSerializedSize () + lsa.first.GetLength () > interface->GetMtu () - 100)
            {
              lsUpdates.emplace_back (lsUpdate);
              lsUpdate = Create<LsUpdate> ();
            }
          lsUpdate->AddLsa (lsa.first, lsa.second);
        }
    }
  for (auto &[remoteRouterId, lsa] : m_app.m_l1SummaryLsdb)
    {
      if (lsr->HasLsaKey (lsa.first.GetKey ()))
        {
          if (lsUpdate->GetSerializedSize () + lsa.first.GetLength () > interface->GetMtu () - 100)
            {
              lsUpdates.emplace_back (lsUpdate);
              lsUpdate = Create<LsUpdate> ();
            }
          lsUpdate->AddLsa (lsa.first, lsa.second);
        }
    }
  for (auto &[remoteAreaId, lsa] : m_app.m_areaLsdb)
    {
      if (lsr->HasLsaKey (lsa.first.GetKey ()))
        {
          if (lsUpdate->GetSerializedSize () + lsa.first.GetLength () > interface->GetMtu () - 100)
            {
              lsUpdates.emplace_back (lsUpdate);
              lsUpdate = Create<LsUpdate> ();
            }
          lsUpdate->AddLsa (lsa.first, lsa.second);
        }
    }
  for (auto &[remoteAreaId, lsa] : m_app.m_l2SummaryLsdb)
    {
      if (lsr->HasLsaKey (lsa.first.GetKey ()))
        {
          if (lsUpdate->GetSerializedSize () + lsa.first.GetLength () > interface->GetMtu () - 100)
            {
              lsUpdates.emplace_back (lsUpdate);
              lsUpdate = Create<LsUpdate> ();
            }
          lsUpdate->AddLsa (lsa.first, lsa.second);
        }
    }
  lsUpdates.emplace_back (lsUpdate);
  NS_LOG_INFO ("Received LSR (" << lsr->GetNLsaKeys () << ") from interface: " << ifIndex);
  for (auto lsUpdate : lsUpdates)
    {
      Ptr<Packet> packet = lsUpdate->ConstructPacket ();
      EncapsulateOspfPacket (packet, m_app.m_routerId, interface->GetArea (),
                             OspfHeader::OspfType::OspfLSUpdate);
      // Implicit Ack, only send once
      m_app.SendToNeighbor (ifIndex, packet, neighbor);
    }
}

void
OspfLsaProcessor::HandleLsu (uint32_t ifIndex, Ipv4Header ipHeader, OspfHeader ospfHeader,
                             Ptr<LsUpdate> lsu)
{
  auto receivedLsa = lsu->GetLsaList ();
  for (auto &[lsaHeader, lsa] : receivedLsa)
    {
      // Handle LSA and send ACK when appropriate
      HandleLsa (ifIndex, ipHeader, ospfHeader, lsaHeader, lsa);
    }
}

void
OspfLsaProcessor::HandleLsa (uint32_t ifIndex, Ipv4Header ipHeader, OspfHeader ospfHeader,
                             LsaHeader lsaHeader, Ptr<Lsa> lsa)
{
  auto interface = m_app.m_ospfInterfaces[ifIndex];
  Ptr<OspfNeighbor> neighbor =
      interface->GetNeighbor (Ipv4Address (ospfHeader.GetRouterId ()), ipHeader.GetSource ());

  if (neighbor == nullptr)
    {
      NS_LOG_WARN ("LSA dropped due to missing neighbor");
      return;
    }

  uint32_t advertisingRouter = lsaHeader.GetAdvertisingRouter ();
  uint32_t seqNum = lsaHeader.GetSeqNum ();
  LsaHeader::LsaKey lsaKey = lsaHeader.GetKey ();

  // Filter out L2 LSA across the area (only happens in multi-access broadcast)
  if (neighbor->GetArea () != m_app.m_areaId &&
      (lsaHeader.GetType () == LsaHeader::RouterLSAs || lsaHeader.GetType () == LsaHeader::L1SummaryLSAs))
    {
      return;
    }

  auto ackPacket = ConstructLSAckPacket (m_app.m_routerId, m_app.m_areaId, lsaHeader);
  // If the LSA was originally generated by the receiving router, the packet is dropped.
  // Ack is sent
  if (advertisingRouter == m_app.m_routerId.Get ())
    {
      NS_LOG_INFO ("LSU is dropped, received LSU has originated here");
      m_app.SendAck (ifIndex, ackPacket, neighbor->GetIpAddress ());
      return;
    }

  // Initialize local seqNum if it does not exist
  if (m_app.m_seqNumbers.find (lsaKey) == m_app.m_seqNumbers.end ())
    {
      m_app.m_seqNumbers[lsaKey] = 0;
    }

  // Satisfy LSR
  bool isLsrSatisfied = false;
  if (neighbor->GetState () == OspfNeighbor::Loading)
    {
      auto lastLsr = neighbor->GetLastLsrSent ();
      if (lastLsr->HasLsaKey (lsaHeader.GetKey ()))
        {
          isLsrSatisfied = true;
          // If LSU is an implicit ACK to LSR
          lastLsr->RemoveLsaKey (lsaHeader.GetKey ());
          if (lastLsr->IsLsaKeyEmpty ())
            {
              m_app.SendNextLsr (ifIndex, neighbor);
            }
        }
    }

  // If the sequence number equals to that of the last packet received from the
  // originating router, the packet is dropped and ACK is sent.
  if (seqNum == m_app.m_seqNumbers[lsaKey])
    {
      if (!isLsrSatisfied)
        {
          m_app.SendAck (ifIndex, ackPacket, neighbor->GetIpAddress ());
        }

      // Remove lsaKey from retx queue
      neighbor->RemoveKeyedTimeout (lsaKey);
      return;
    }
  else if (seqNum > m_app.m_seqNumbers[lsaKey])
    {
      NS_LOG_INFO ("Installing new LSA: " << seqNum << " > " << m_app.m_seqNumbers[lsaKey]);
      // New LSA
      // Process LSA and update its Seq num
      ProcessLsa (lsaHeader, lsa);

      // Remove lsaKey from retx queue
      neighbor->RemoveKeyedTimeout (lsaKey);

      // Flood the network
      Ptr<LsUpdate> lsUpdate = Create<LsUpdate> ();
      lsUpdate->AddLsa (lsaHeader, lsa);
      m_app.FloodLsu (ifIndex, lsUpdate);

      // Send ACK
      if (!isLsrSatisfied)
        {
          m_app.SendAck (ifIndex, ackPacket, neighbor->GetIpAddress ());
        }
      return;
    }
  else if (!isLsrSatisfied)
    {
      // Stale LSA
      NS_LOG_WARN ("Received stale LSA " << seqNum << " < " << m_app.m_seqNumbers[lsaKey]);
      // Just send ACK
      m_app.SendAck (ifIndex, ackPacket, neighbor->GetIpAddress ());
    }
}

void
OspfLsaProcessor::ProcessLsa (LsaHeader lsaHeader, Ptr<Lsa> lsa)
{
  if (m_app.m_enableLog)
    {
      m_app.PrintLsaTiming (lsaHeader.GetSeqNum (), lsaHeader.GetKey (), Simulator::Now ());
    }
  // Update seq num
  m_app.m_seqNumbers[lsaHeader.GetKey ()] = lsaHeader.GetSeqNum ();
  switch (lsaHeader.GetType ())
    {
    case LsaHeader::RouterLSAs:
      m_app.ProcessRouterLsa (lsaHeader, DynamicCast<RouterLsa> (lsa));
      break;
    case LsaHeader::L1SummaryLSAs:
      m_app.ProcessL1SummaryLsa (lsaHeader, DynamicCast<L1SummaryLsa> (lsa));
      break;
    case LsaHeader::AreaLSAs:
      m_app.ProcessAreaLsa (lsaHeader, DynamicCast<AreaLsa> (lsa));
      break;
    case LsaHeader::L2SummaryLSAs:
      m_app.ProcessL2SummaryLsa (lsaHeader, DynamicCast<L2SummaryLsa> (lsa));
      break;
    default:
      NS_LOG_WARN ("Received unsupport LSA type in received LS Update");
      break;
    }
}

void
OspfLsaProcessor::ProcessLsa (std::pair<LsaHeader, Ptr<Lsa>> lsa)
{
  ProcessLsa (lsa.first, lsa.second);
}

void
OspfLsaProcessor::HandleLsAck (uint32_t ifIndex, Ipv4Header ipHeader, OspfHeader ospfHeader,
                               Ptr<LsAck> lsAck)
{
  auto interface = m_app.m_ospfInterfaces[ifIndex];
  Ptr<OspfNeighbor> neighbor =
      interface->GetNeighbor (Ipv4Address (ospfHeader.GetRouterId ()), ipHeader.GetSource ());
  auto lsaHeaders = lsAck->GetLsaHeaders ();
  if (neighbor == nullptr)
    {
      NS_LOG_WARN ("LS Ack dropped due to missing neighbor ("
                   << Ipv4Address (ospfHeader.GetRouterId ()) << "," << ipHeader.GetSource ()
                   << ")");
      return;
    }

  if (neighbor->GetState () < OspfNeighbor::Exchange)
    {
      NS_LOG_WARN ("LS Ack dropped since the neighbor hasn't started exchange ("
                   << Ipv4Address (ospfHeader.GetRouterId ()) << "," << ipHeader.GetSource ()
                   << ")");
      return;
    }

  for (auto lsaHeader : lsaHeaders)
    {
      // Remove timeout if the stored seq num have been satisfied
      if (lsaHeader.GetSeqNum () <= m_app.m_seqNumbers[lsaHeader.GetKey ()])
        {
          bool isRemoved = neighbor->RemoveKeyedTimeout (lsaHeader.GetKey ());
          if (isRemoved)
            {
              NS_LOG_INFO ("Removed key (advertising router): "
                           << Ipv4Address (lsaHeader.GetAdvertisingRouter ())
                           << " from the retx timer");
            }
          else
            {
              NS_LOG_INFO ("Key: " << Ipv4Address (lsaHeader.GetAdvertisingRouter ())
                                   << " does not exist in the retx timer");
            }
        }
    }
}

} // namespace ns3
